import torch
import numpy as np
import torch.nn.functional as F
from sklearn.metrics import recall_score


class DiceScore(object):
    r"""
    Computes the Sørensen–Dice between two images.
    Args:
        to_one_hot (bool): Convert the tensor to one-hot encoding.
        n_classes (int): Number of classes in the dataset.
        apply_activation (bool): Apply sigmoid activation function to the raw input.
    """
    def __init__(self, to_one_hot, n_classes, apply_activation=True):
        self.to_one_hot = to_one_hot
        self.n_classes = n_classes
        self.apply_activation = apply_activation

    def __call__(self, inputs, targets):
        with torch.set_grad_enabled(False):
            if self.apply_activation:
                inputs = torch.sigmoid(inputs)

            if self.to_one_hot:
                targets = torch.squeeze(targets.long())
                targets = F.one_hot(torch.squeeze(targets.long()), num_classes=self.n_classes)
                targets = targets.permute(0, 3, 1, 2)
                if inputs.size()[1] == 1:
                    inputs = torch.round(inputs)
                    inputs = F.one_hot(torch.squeeze(inputs.long()), num_classes=self.n_classes).permute(0, 3, 1, 2)

            inputs, targets = inputs.reshape(1, -1).squeeze(), targets.reshape(1, -1).squeeze()
            intersection = (inputs * targets).sum()
            dice = (2. * intersection) / (inputs.sum() + targets.sum())

            return dice


def get_sensitivity_score(y_true, y_pred):
    return recall_score(y_true, y_pred)


def get_specificity_score(y_true, y_pred):
    if isinstance(y_true, list):
        y_true = np.array(y_true)
    if isinstance(y_pred, list):
        y_pred = np.array(y_pred)

    y_true, y_pred = 1 - y_true, 1 - y_pred
    return get_sensitivity_score(y_true, y_pred)


def get_masked_data(y_true, y_pred, y_mask):
    r"""
    Extract the information of the estimation and label images according to the FOV mask.
    :param y_true: numpy array
        Label image.
    :param y_pred: numpy array
        Estimation generated by the model.
    :param y_mask:
        FOV mask of the label image.
    :return: tuple
        (valid elements in the label image, valid elements in the estimates image)
    """
    y_true, y_pred, y_mask = y_true.flatten(), y_pred.flatten(), y_mask.flatten()
    return y_true[y_mask == 1], y_pred[y_mask == 1]
